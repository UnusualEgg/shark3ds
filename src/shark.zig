const w4 = @import("common.zig");
const std = @import("std");
const sdl = @import("sdl.zig");
//TODO use sdl and the texture atlas from main.zig

pub const surfer_width = 26;
pub const surfer_height = 26;
// pub const surfer_flags = 0; // BLIT_1BPP
// pub const surfer: [3][85]u8 = [3][85]u8{
//     [85]u8{ 0x00, 0x3c, 0x00, 0x00, 0x0f, 0x07, 0x80, 0x03, 0xcf, 0xe0, 0x00, 0xf7, 0xe0, 0x00, 0x3f, 0xf0, 0x00, 0x1f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x0f, 0xfc, 0x00, 0x07, 0xff, 0x00, 0x03, 0xdf, 0xc0, 0x01, 0xf7, 0xf8, 0x00, 0x79, 0xfe, 0x00, 0x1e, 0x7f, 0xc0, 0x06, 0x0f, 0xf8, 0x01, 0x83, 0xff, 0x84, 0x00, 0xf3, 0xf7, 0x00, 0x3c, 0x7f, 0xc0, 0x0e, 0x0f, 0xf0, 0x07, 0x8f, 0xfc, 0x01, 0xff, 0xfe, 0x00, 0xff, 0xfc, 0x01, 0xff, 0xfe, 0x00, 0xff, 0xf8, 0x03, 0xff, 0xf0, 0x00, 0xff, 0xc0, 0x00, 0x3f, 0x80, 0x00, 0x00 },
//     [85]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x07, 0xc0, 0x00, 0x3f, 0xf6, 0x00, 0x3f, 0xff, 0xe0, 0x1f, 0x7f, 0xfe, 0x0e, 0x1f, 0xc3, 0xc3, 0x0f, 0xf0, 0x30, 0x03, 0xf8, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x1f, 0xe0, 0x00, 0x07, 0xfc, 0x00, 0x03, 0xcf, 0x00, 0x33, 0xe1, 0xe0, 0x3f, 0xf8, 0x78, 0x0f, 0xff, 0xff, 0x03, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xf0, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
//     [85]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0xf0, 0x00, 0x7f, 0xf8, 0x00, 0x7f, 0xfe, 0x00, 0x1c, 0x3f, 0xf8, 0x00, 0x1f, 0xff, 0x80, 0x0f, 0xf0, 0xf0, 0x03, 0xfc, 0x0c, 0x00, 0xfe, 0x01, 0x00, 0x7f, 0x80, 0x00, 0x1f, 0xe0, 0x0f, 0x3f, 0x78, 0x03, 0xff, 0x8f, 0x00, 0xff, 0xe3, 0xc0, 0x3f, 0xff, 0xf0, 0x03, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x7f, 0xfe, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
// };
pub const water_width = 160;
pub const water_height = 12;
// pub const water_flags = 0; // BLIT_1BPP
// pub const water = [240]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xe7, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xff, 0x80, 0x0f, 0xff, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf9, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00, 0xff, 0x9c, 0x1f, 0xfe, 0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x39, 0xff, 0xfe, 0x1c, 0x03, 0xff, 0xfc, 0x3f, 0xfe, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x38, 0x00, 0x00, 0x07, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0x80, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

pub const shark_width = 49;
pub const shark_height = 36;
// pub const shark_flags = 1; // BLIT_2BPP
// pub const shark = [441]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x45, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x55, 0x55, 0x55, 0x7f, 0x54, 0x05, 0x40, 0x00, 0x00, 0x01, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x50, 0x00, 0x00, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x54, 0x00, 0x00, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x45, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x50, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x40, 0x15, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x40, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x50, 0x00, 0x00, 0x15, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x50, 0x00, 0x00, 0x01, 0x55, 0x50, 0x15, 0x55, 0x55, 0x55, 0x55, 0x55, 0x50, 0x00, 0x00, 0x00, 0x15, 0x00, 0x05, 0x55, 0x55, 0x55, 0x55, 0x51, 0x55, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x01, 0x55, 0x55, 0x55, 0x00, 0x15, 0x40, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

pub fn start() void {
    // w4.PALETTE.* = .{
    //     0x5995d1, //sky blue (light)
    //     0xffffff, //white
    //     0x1d456d, //water blue (dark)
    //     0x58dd58, //green
    // };
}

//everything is moved by surfer_speed
var surfer_speed: f32 = 0;
const max_speed: f32 = 5;
const surfer_x: i32 = 160 / 2;
const speed_change: f32 = 0.225;

var shark_x: i32 = 160;

const shark_speed: i32 = @as(i32, @intFromFloat(max_speed)) / 2;

var beam: i32 = 0;
const beam_width: i32 = 50;

var shark_alive: bool = true;

var prev_button2_state: bool = false;
var moved: bool = false;
const data = [1]u8{0b1111_1111};
pub fn update(ren: *sdl.Renderer, atlas: *sdl.Texture, title: *sdl.Texture) void {
    //update
    const gamepad = w4.GAMEPAD1.*;

    const curr_button2_state = gamepad & w4.BUTTON_2 != 0;
    if (curr_button2_state and !prev_button2_state and beam == 0) {
        shark_alive = true;
        surfer_speed = 0;
        shark_x = 160;
    }
    prev_button2_state = gamepad & w4.BUTTON_2 != 0;
    if (gamepad & (w4.BUTTON_LEFT | w4.BUTTON_RIGHT | w4.BUTTON_1) != 0) moved = true;

    if (gamepad & w4.BUTTON_1 != 0 and beam == 0 and shark_alive) {
        beam = beam_width;
        const shark_half = shark_width / 2;
        const shark_right = shark_x + shark_half;
        const shark_left = shark_x - shark_half;
        const screen_middle = 160 / 2;
        const beam_half = (beam_width / 2);
        const beam_left = screen_middle - beam_half;
        const beam_right = screen_middle + beam_half;
        if (shark_right >= beam_left and shark_left <= beam_right) {
            shark_alive = false;
        }
    }

    if (shark_alive) {
        if (gamepad & w4.BUTTON_RIGHT != 0) {
            surfer_speed += speed_change;
        }
        if (gamepad & w4.BUTTON_LEFT != 0) {
            surfer_speed -= speed_change;
        }
        if (surfer_speed < 0) {
            surfer_speed = 0;
        }
        if (surfer_speed > max_speed) {
            surfer_speed = max_speed;
        }
    }

    if (shark_alive) {
        shark_x += shark_speed;
        shark_x -= @intFromFloat(surfer_speed);
        //stop the shark at 4 screens ahead
        if (shark_x > 160 * 4) {
            shark_x = 160 * 4;
        }
    }

    //3 equally spaced states of rotation
    const surfer_index: usize =
        if (!shark_alive) 0 else if (surfer_speed >= (max_speed * (2.0 / 3.0))) 2 else if (surfer_speed > (max_speed / 3.0)) 1 else 0;
    //draw
    if (!moved) {
        //TODO draw the texture using title.png
        // w4.DRAW_COLORS.* = 2;
        // const title: []const u8 = "My dream game :3";
        // w4.text(title, (160 / 2) - ((title.len / 2) * w4.FONT_SIZE), 10);
        //16 len
        try ren.renderTexture(title, null, sdl.FRect{ .w = 8 * 16, .h = 16, .x = (160 / 2) - ((16 / 2) * 8), .y = 10 });
    }

    try draw_water(@intFromFloat(surfer_speed));

    //surfer
    // w4.DRAW_COLORS.* = 0x0040;
    //blit uses top left corner for the position of sprites
    //so move surfer half over
    const surfer = [3]sdl.FRect{
        sdl.FRect{ .w = surfer_width, .h = surfer_height, .x = water_height + (surfer_width * 0), .y = shark_height + (surfer_height * 1) },
        sdl.FRect{ .w = surfer_width, .h = surfer_height, .x = water_height + (surfer_width * 1), .y = shark_height + (surfer_height * 0) },
        sdl.FRect{ .w = surfer_width, .h = surfer_height, .x = water_height + (surfer_width * 0), .y = shark_height + (surfer_height * 0) },
    };
    try ren.renderTexture(
        atlas,
        surfer[surfer_index],
        sdl.FRect{ .x = surfer_x - (surfer_width / 2), .y = 51 },
    );
    // w4.blit(&surfer[surfer_index], surfer_x - (surfer_width / 2), 51, surfer_width, surfer_height, w4.BLIT_1BPP);

    //shark
    // w4.DRAW_COLORS.* = 0x4020;
    const shark = sdl.FRect{
        .x = water_height,
        .y = 0,
        .w = shark_width,
        .h = shark_height,
    };
    const shark_dest = sdl.FRect{
        .x = shark_x,
        .y = 92,
        .w = shark_width,
        .h = shark_height,
    };
    ren.renderTexture(atlas, shark, shark_dest);
    // w4.blit(&shark, shark_x, 92, shark_width, shark_height, w4.BLIT_2BPP);

    if (beam > 0) {
        // w4.DRAW_COLORS.* = 0x0002;
        ren.renderFillRect(.{
            .x = @floatFromInt((surfer_x) - @divFloor(beam, 2)),
            .y = 0,
            .w = @floatFromInt(beam),
            .h = 160,
        });
        // w4.rect((surfer_x) - @divFloor(beam, 2), 0, @intCast(beam), 160);
    }
    //shrink beam over time
    beam -= 2;
    if (beam < 0) {
        beam = 0;
    }
}

var water_x: i32 = 0;
fn draw_water(ren: *sdl.Renderer, atlas: *sdl.Texture, speed: i32) !void {
    //only the top of the water uses a sprite
    //water
    w4.DRAW_COLORS.* = 0x0030;
    const water_y: i32 = 60;
    //we use two to make it look endless
    const water = sdl.FRect{
        .x = 0,
        .y = 0,
        .w = water_height,
        .h = water_width,
    };
    const water_dest = sdl.FRect{
        .x = water_x,
        .y = water_y,
        .w = water_height,
        .h = water_width,
    };
    //TODO does extending water_dest.h tile?
    try ren.renderTextureRotated(
        atlas,
        water,
        water_dest,
        90,
        sdl.FPoint{ .x = water_height, .y = water_width },
        .NONE,
    );
    w4.blit(&water, water_x, water_y, 160, water_height, w4.BLIT_1BPP);
    w4.blit(&water, water_x + 160, water_y, 160, water_height, w4.BLIT_1BPP);

    if (shark_alive) {
        water_x -|= speed;
    }
    //them forward to keep looping so we never run out of water
    while (water_x <= -160) {
        water_x += 160;
    }

    //fill in bottom half of screen that isn't detailed and thus doesn't need a sprite
    // w4.DRAW_COLORS.* = 0x0003;
    // w4.rect(0, water_y + water_height, 160, 160 - (water_y + water_height));
    try ren.renderFillRect(.{ .x = 0, .y = water_y + water_height, .w = 160, .h = 160 - (water_y + water_height) });
}
